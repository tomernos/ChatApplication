@Library('jenkins-shared-library') _

pipeline {
    agent {
        docker {
            image 'alpine/k8s:1.28.0'
            args '-v /var/run/docker.sock:/var/run/docker.sock -u root'
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        AWS_REGION = 'eu-central-1'
        AWS_CREDENTIALS_ID = 'aws-creds'
        CLUSTER_NAME = 'tnt-eu-observability-dev-eks'
        
        // ECR Registry (should be set from CI pipeline artifacts or parameter)
        ECR_REGISTRY = ''
        ECR_BACKEND_REPO = 'connecthub-backend'
        ECR_FRONTEND_REPO = 'connecthub-frontend'
        
        // Version (should be passed as parameter or from CI pipeline)
        VERSION = ''
        
        // Detect branch
        BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH?.replaceAll('origin/', '') ?: 'unknown'}"
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target environment to deploy to'
        )
        string(
            name: 'IMAGE_VERSION',
            defaultValue: '',
            description: 'Override: Docker image version to deploy. Leave empty to read from deployment.yaml'
        )
        string(
            name: 'ECR_REGISTRY_PARAM',
            defaultValue: '',
            description: 'Override: ECR Registry URL. Leave empty to read from deployment.yaml'
        )
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install Tools') {
            steps {
                script {
                    logMessage('Installing required tools', 'üì¶')
                    
                    sh '''
                        # Install AWS CLI
                        apk add --no-cache curl unzip python3 py3-pip
                        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                        unzip awscliv2.zip
                        ./aws/install
                        rm -rf awscliv2.zip aws
                        
                        # Install Helm
                        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
                        
                        # Verify tools
                        kubectl version --client
                        helm version
                        aws --version
                    '''
                }
            }
        }

        stage('Read Deployment Manifest') {
            steps {
                script {
                    logMessage('Reading Deployment Manifest', 'üìñ')
                    
                    // Determine environment using Groovy logic (no shell script)
                    def environment = params.ENVIRONMENT
                    
                    if (!environment || environment.isEmpty()) {
                        // Determine from branch name
                        def normalizedBranch = BRANCH.replaceAll('origin/', '')
                        
                        if (normalizedBranch == 'develop') {
                            environment = 'dev'
                        } else if (normalizedBranch =~ /^release\//) {
                            environment = 'staging'
                        } else if (normalizedBranch == 'main' || normalizedBranch =~ /^hotfix\//) {
                            environment = 'prod'
                        } else if (normalizedBranch =~ /^feature\//) {
                            environment = 'preview'
                        } else {
                            environment = 'unknown'
                        }
                    }
                    
                    if (environment == 'unknown' || environment.isEmpty()) {
                        error("Cannot determine environment from branch ${BRANCH}. Please specify ENVIRONMENT parameter.")
                    }
                    
                    env.DEPLOY_ENVIRONMENT = environment
                    
                    // Read deployment manifest
                    def deploymentFile = "deployments/${environment}/deployment.yaml"
                    
                    if (!fileExists(deploymentFile)) {
                        error("Deployment manifest not found: ${deploymentFile}. Ensure CI has run and updated the manifest.")
                    }
                    
                    // Parse deployment.yaml
                    def manifestContent = readFile deploymentFile
                    def manifest = [:]
                    
                    // Simple YAML parsing (basic key: value format)
                    manifestContent.split('\n').each { line ->
                        def trimmed = line.trim()
                        if (trimmed && !trimmed.startsWith('#') && trimmed.contains(':')) {
                            def parts = trimmed.split(':', 2)
                            if (parts.length == 2) {
                                def key = parts[0].trim()
                                def value = parts[1].trim().replaceAll(/^["']|["']$/, '')
                                manifest[key] = value
                            }
                        }
                    }
                    
                    // Set version and registry from manifest (or override from parameters)
                    if (params.IMAGE_VERSION && !params.IMAGE_VERSION.isEmpty()) {
                        env.DEPLOY_VERSION = params.IMAGE_VERSION
                        echo "‚ö†Ô∏è  Using override version: ${env.DEPLOY_VERSION}"
                    } else if (manifest.version && !manifest.version.isEmpty()) {
                        env.DEPLOY_VERSION = manifest.version
                        echo "‚úÖ Using version from manifest: ${env.DEPLOY_VERSION}"
                    } else {
                        error("No version found in deployment manifest and no override provided.")
                    }
                    
                    if (params.ECR_REGISTRY_PARAM && !params.ECR_REGISTRY_PARAM.isEmpty()) {
                        env.ECR_REGISTRY = params.ECR_REGISTRY_PARAM
                        echo "‚ö†Ô∏è  Using override ECR registry: ${env.ECR_REGISTRY}"
                    } else if (manifest.ecr_registry && !manifest.ecr_registry.isEmpty()) {
                        env.ECR_REGISTRY = manifest.ecr_registry
                        echo "‚úÖ Using ECR registry from manifest: ${env.ECR_REGISTRY}"
                    } else {
                        // Fallback: auto-detect
                        withCredentials([usernamePassword(
                            credentialsId: AWS_CREDENTIALS_ID,
                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )]) {
                            def accountId = sh(
                                script: 'aws sts get-caller-identity --query Account --output text 2>&1',
                                returnStdout: true
                            ).trim()
                            env.ECR_REGISTRY = "${accountId}.dkr.ecr.${AWS_REGION}.amazonaws.com"
                            echo "‚úÖ Auto-detected ECR registry: ${env.ECR_REGISTRY}"
                        }
                    }
                    
                    env.BACKEND_REPO = manifest.backend_repo ?: ECR_BACKEND_REPO
                    env.FRONTEND_REPO = manifest.frontend_repo ?: ECR_FRONTEND_REPO
                    
                    echo """
                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë  DEPLOYMENT INFORMATION                 ‚ïë
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    Environment:  ${env.DEPLOY_ENVIRONMENT}
                    Version:      ${env.DEPLOY_VERSION}
                    ECR Registry: ${env.ECR_REGISTRY}
                    Backend:      ${env.ECR_REGISTRY}/${env.BACKEND_REPO}:${env.DEPLOY_VERSION}
                    Frontend:     ${env.ECR_REGISTRY}/${env.FRONTEND_REPO}:${env.DEPLOY_VERSION}
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    """.stripIndent()
                }
            }
        }

        stage('Authenticate to AWS') {
            steps {
                script {
                    logMessage('Authenticating to AWS', 'üîê')
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            aws sts get-caller-identity
                            echo "‚úÖ AWS authenticated"
                        """
                    }
                }
            }
        }

        stage('Configure Kubeconfig') {
            steps {
                script {
                    logMessage('Configuring kubectl for EKS cluster', '‚öôÔ∏è')
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            echo "üîß Updating kubeconfig for cluster: ${CLUSTER_NAME}"
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                            
                            echo "‚úÖ Verifying cluster access..."
                            kubectl cluster-info
                            kubectl get nodes
                        """
                    }
                }
            }
        }

        stage('Approve Production Deployment') {
            when {
                expression { env.DEPLOY_ENVIRONMENT == 'prod' }
            }
            steps {
                script {
                    logMessage('Production Deployment Approval Required', 'üö®')
                    
                    def approval = input(
                        message: "üö® Deploy ${env.DEPLOY_VERSION} to PRODUCTION?",
                        ok: 'Deploy to Production',
                        parameters: [
                            string(
                                name: 'DEPLOYMENT_REASON',
                                description: 'Why are you deploying to production?'
                            )
                        ]
                    )
                    
                    env.DEPLOYMENT_REASON = approval.DEPLOYMENT_REASON ?: 'No reason provided'
                    echo "‚úÖ Production deployment approved"
                    echo "Reason: ${env.DEPLOYMENT_REASON}"
                }
            }
        }

        stage('Helm Deploy Application') {
            steps {
                script {
                    logMessage('Deploying application via Helm', 'üöÄ')
                    
                    // Verify required variables are set
                    if (!env.ECR_REGISTRY || env.ECR_REGISTRY.isEmpty()) {
                        error("ECR_REGISTRY is not set! Check deployment manifest or provide ECR_REGISTRY_PARAM.")
                    }
                    
                    if (!env.DEPLOY_VERSION || env.DEPLOY_VERSION.isEmpty()) {
                        error("DEPLOY_VERSION is not set! Check deployment manifest or provide IMAGE_VERSION.")
                    }
                    
                    def namespace = "chatapp-${env.DEPLOY_ENVIRONMENT}"
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        dir('ChatApplication') {
                            sh """
                                echo "üì¶ Deploying with Helm..."
                                echo "Environment: ${env.DEPLOY_ENVIRONMENT}"
                                echo "Namespace: ${namespace}"
                                echo "Chart: helm-chart/"
                                echo "Backend Image: ${env.ECR_REGISTRY}/${env.BACKEND_REPO}:${env.DEPLOY_VERSION}"
                                echo "Frontend Image: ${env.ECR_REGISTRY}/${env.FRONTEND_REPO}:${env.DEPLOY_VERSION}"
                                
                                # Verify variables are not empty
                                ECR_REG="${env.ECR_REGISTRY}"
                                VERSION="${env.DEPLOY_VERSION}"
                                BACKEND_REPO="${env.BACKEND_REPO}"
                                FRONTEND_REPO="${env.FRONTEND_REPO}"
                                
                                if [ -z "\$ECR_REG" ] || [ -z "\$VERSION" ]; then
                                    echo "‚ùå ECR_REGISTRY or VERSION is empty! Cannot deploy."
                                    exit 1
                                fi
                                
                                helm upgrade --install chatapp ./helm-chart \\
                                    --namespace ${namespace} \\
                                    --create-namespace \\
                                    --set backend.image.repository=\${ECR_REG}/\${BACKEND_REPO} \\
                                    --set backend.image.tag=\${VERSION} \\
                                    --set frontend.image.repository=\${ECR_REG}/\${FRONTEND_REPO} \\
                                    --set frontend.image.tag=\${VERSION} \\
                                    --wait \\
                                    --timeout 10m
                                
                                echo "‚úÖ Helm deployment completed"
                            """
                        }
                    }
                }
            }
        }

        stage('Post-Deployment Smoke Tests') {
            steps {
                script {
                    logMessage('Running Post-Deployment Smoke Tests', 'üî¨')
                    
                    def namespace = "chatapp-${env.DEPLOY_ENVIRONMENT}"
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            CLUSTER="${CLUSTER_NAME}"
                            echo "Environment: ${env.DEPLOY_ENVIRONMENT}"
                            echo "Version: ${env.DEPLOY_VERSION}"
                            echo "Namespace: ${namespace}"
                            echo "Cluster: \$CLUSTER"
                            echo ""
                            
                            echo "üîç Checking deployment status..."
                            kubectl rollout status deployment/chatapp-backend -n ${namespace} --timeout=5m || true
                            kubectl rollout status deployment/chatapp-frontend -n ${namespace} --timeout=5m || true
                            
                            echo ""
                            echo "üìä Checking pod status..."
                            kubectl get pods -n ${namespace}
                            
                            echo ""
                            echo "üåê Checking services..."
                            kubectl get svc -n ${namespace}
                            
                            echo ""
                            echo "üî¨ Running health check..."
                            # Port-forward to backend and test health endpoint
                            kubectl port-forward -n ${namespace} svc/chatapp-backend 5000:5000 &
                            PF_PID=\$!
                            sleep 5
                            
                            if curl -f http://localhost:5000/health; then
                                echo "‚úÖ Backend health check passed"
                                kill \$PF_PID || true
                            else
                                echo "‚ùå Backend health check failed"
                                kill \$PF_PID || true
                                exit 1
                            fi
                            
                            echo ""
                            echo "‚úÖ All smoke tests passed"
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                logMessage('CD Pipeline Completed', 'üìä')
            }
        }
        success {
            script {
                logMessage('CD Pipeline Completed Successfully!', '‚úÖ')
            }
        }
        failure {
            script {
                logMessage('CD Pipeline Failed!', '‚ùå')
            }
        }
    }
}

