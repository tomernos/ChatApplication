@Library('jenkins-shared-library') _

pipeline {
    agent {
        docker {
            // Using Ubuntu instead of Alpine for better AWS CLI/kubectl compatibility
            // Alpine's musl libc causes issues with AWS CLI exec plugins in kubeconfig
            image 'ubuntu:22.04'
            args '-v /var/run/docker.sock:/var/run/docker.sock -u root'
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        AWS_REGION = 'eu-central-1'
        AWS_CREDENTIALS_ID = 'aws-creds'
        GIT_CREDENTIALS_ID = 'gitpat'  // For Git operations (promotion commits)
        
        // Cluster name - modular: can be per-environment or shared
        // Format: {tenant}-{region}-{project}-{env}-eks
        // For now: single cluster for all environments (modular for future separation)
        CLUSTER_NAME = 'tnt-eu-chatapp-dev-eks'  // TODO: Make environment-aware if separate clusters needed
        
        // ECR Registry (should be set from CI pipeline artifacts or parameter)
        ECR_REGISTRY = ''
        ECR_REPO = 'chatapp'  // Single ECR repository for both backend and frontend (modular for future separation)
        
        // Version (should be passed as parameter or from CI pipeline)
        VERSION = ''
        
        // Detect branch
        BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH?.replaceAll('origin/', '') ?: 'unknown'}"
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target environment to deploy to'
        )
        string(
            name: 'IMAGE_VERSION',
            defaultValue: '',
            description: 'Override: Docker image version to deploy. Leave empty to read from deployment.yaml'
        )
        string(
            name: 'ECR_REGISTRY_PARAM',
            defaultValue: '',
            description: 'Override: ECR Registry URL. Leave empty to read from deployment.yaml'
        )
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install Tools') {
            steps {
                script {
                    logMessage('Installing required tools', 'üì¶')
                    
                    sh '''
                        set -e
                        
                        # Update package list
                        apt-get update -qq
                        
                        # Install base dependencies (including git for promotion commits)
                        apt-get install -y -qq curl unzip ca-certificates gnupg lsb-release git
                        
                        # Install kubectl
                        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
                        echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | tee /etc/apt/sources.list.d/kubernetes.list
                        apt-get update -qq
                        apt-get install -y -qq kubectl
                        
                        # Install AWS CLI v2
                        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                        unzip -q awscliv2.zip
                        ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
                        rm -rf awscliv2.zip aws
                        
                        # Install Helm
                        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
                        
                        # Verify all tools
                        echo "‚úÖ Tool versions:"
                        git --version
                        kubectl version --client
                        helm version
                        aws --version
                    '''
                }
            }
        }

        stage('Promote Version (Auto)') {
            when {
                // Disabled: Not using promotion per environment for now
                // Staging and prod will use their own CI-built images
                expression { return false }
                // anyOf {
                //     branch 'staging'
                //     branch 'prod'
                //     branch 'main'
                // }
            }
            steps {
                script {
                    logMessage('Auto-Promoting Version', 'üîÑ')
                    
                    def normalizedBranch = BRANCH.replaceAll('origin/', '')
                    def sourceEnv = null
                    def targetEnv = null
                    
                    // Determine promotion path based on branch
                    if (normalizedBranch == 'staging') {
                        sourceEnv = 'dev'
                        targetEnv = 'staging'
                    } else if (normalizedBranch == 'prod' || normalizedBranch == 'main') {
                        sourceEnv = 'staging'
                        targetEnv = 'prod'
                    }
                    
                    if (sourceEnv && targetEnv) {
                        echo "üîÑ Auto-promoting from ${sourceEnv} to ${targetEnv}"
                        
                        // Read source manifest
                        def sourceFile = "deployments/${sourceEnv}/deployment.yaml"
                        if (!fileExists(sourceFile)) {
                            error("Source manifest not found: ${sourceFile}. Cannot promote.")
                        }
                        
                        // Parse source manifest
                        def sourceContent = readFile sourceFile
                        def sourceManifest = [:]
                        sourceContent.split('\n').each { line ->
                            def trimmed = line.trim()
                            if (trimmed && !trimmed.startsWith('#') && trimmed.contains(':')) {
                                def parts = trimmed.split(':', 2)
                                if (parts.length == 2) {
                                    def key = parts[0].trim()
                                    def value = parts[1].trim().replaceAll(/^["']|["']$/, '')
                                    if (value != 'null' && !value.isEmpty() && value != '""' && value != "''") {
                                        sourceManifest[key] = value
                                    }
                                }
                            }
                        }
                        
                        // Validate source manifest has version
                        if (!sourceManifest.version || sourceManifest.version.isEmpty()) {
                            error("Source manifest (${sourceEnv}) has no version. Cannot promote.")
                        }
                        
                        echo "‚úÖ Source version: ${sourceManifest.version}"
                        echo "‚úÖ Source backend image: ${sourceManifest.backend_image}"
                        
                        // Create target manifest
                        def timestamp = new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))
                        def targetFile = "deployments/${targetEnv}/deployment.yaml"
                        def targetContent = """# Deployment Manifest - ${targetEnv.capitalize()} Environment
# Auto-promoted from ${sourceEnv} environment by CD pipeline
# DO NOT manually edit - CD will overwrite changes
# Last updated: ${timestamp}

version: "${sourceManifest.version}"
ecr_registry: "${sourceManifest.ecr_registry}"
ecr_repo: "${sourceManifest.ecr_repo ?: 'chatapp'}"
backend_image: "${sourceManifest.backend_image}"
frontend_image: "${sourceManifest.frontend_image}"
deployed_at: "${timestamp}"
deployed_by: "jenkins-cd"
git_commit: "${env.GIT_COMMIT}"
git_branch: "${normalizedBranch}"
promoted_from: "${sourceEnv}"
promoted_at: "${timestamp}"
"""
                        
                        // Write target manifest
                        writeFile file: targetFile, text: targetContent
                        echo "‚úÖ Created target manifest: ${targetFile}"
                        
                        // Commit and push promotion
                        withCredentials([usernamePassword(
                            credentialsId: GIT_CREDENTIALS_ID,
                            usernameVariable: 'GIT_USERNAME',
                            passwordVariable: 'GIT_PASSWORD'
                        )]) {
                            sh """
                                git config user.name "Jenkins CD"
                                git config user.email "jenkins@cd.local"
                                
                                git add ${targetFile}
                                
                                if git diff --staged --quiet; then
                                    echo "‚ÑπÔ∏è  No changes to commit (manifest already has this version)"
                                else
                                    git commit -m "CD: Auto-promote ${sourceManifest.version} from ${sourceEnv} to ${targetEnv} [skip ci]" || true
                                    
                                    git remote set-url origin https://\${GIT_USERNAME}:\${GIT_PASSWORD}@\$(echo ${env.GIT_URL} | sed -E 's|.*github.com[:/](.*)\\.git|github.com/\\1|' | sed 's|git@||')
                                    git push origin ${normalizedBranch} || git push origin HEAD:${normalizedBranch} || true
                                    echo "‚úÖ Promotion committed and pushed"
                                fi
                            """
                        }
                        
                        echo "‚úÖ Auto-promotion complete: ${sourceManifest.version} promoted to ${targetEnv}"
                    }
                }
            }
        }

        stage('Read Deployment Manifest') {
            steps {
                script {
                    logMessage('Reading Deployment Manifest', 'üìñ')
                    
                    // Debug: Show branch detection
                    echo "üîç Debug - Branch detection:"
                    echo "  BRANCH variable: ${BRANCH}"
                    echo "  env.BRANCH_NAME: ${env.BRANCH_NAME ?: 'not set'}"
                    echo "  env.GIT_BRANCH: ${env.GIT_BRANCH ?: 'not set'}"
                    echo "  params.ENVIRONMENT: ${params.ENVIRONMENT ?: 'not set'}"
                    
                    // Determine environment: Prioritize branch detection for auto-promotion
                    // Only use parameter if branch detection fails
                    def normalizedBranch = BRANCH.replaceAll('origin/', '')
                    echo "  Normalized branch: ${normalizedBranch}"
                    
                    def environment = null
                    
                    // First, try to detect from branch (for auto-promotion)
                    if (normalizedBranch == 'develop') {
                        environment = 'dev'
                    } else if (normalizedBranch == 'staging' || normalizedBranch =~ /^release\//) {
                        environment = 'staging'
                    } else if (normalizedBranch == 'main' || normalizedBranch == 'prod' || normalizedBranch =~ /^hotfix\//) {
                        environment = 'prod'
                    } else if (normalizedBranch =~ /^feature\//) {
                        environment = 'preview'
                    }
                    
                    // If branch detection failed, use parameter (fallback)
                    if (!environment || environment.isEmpty()) {
                        if (params.ENVIRONMENT && !params.ENVIRONMENT.isEmpty()) {
                            environment = params.ENVIRONMENT
                            echo "  ‚ö†Ô∏è  Branch detection failed, using parameter: ${environment}"
                        } else {
                            environment = 'unknown'
                            echo "  ‚ùå Cannot determine environment from branch or parameter"
                        }
                    } else {
                        echo "  ‚úÖ Detected environment from branch: ${environment}"
                        // Warn if parameter doesn't match branch (but still use branch)
                        if (params.ENVIRONMENT && !params.ENVIRONMENT.isEmpty() && params.ENVIRONMENT != environment) {
                            echo "  ‚ö†Ô∏è  WARNING: Parameter ENVIRONMENT=${params.ENVIRONMENT} doesn't match branch ${normalizedBranch} (using ${environment})"
                        }
                    }
                    
                    if (environment == 'unknown' || environment.isEmpty()) {
                        error("Cannot determine environment from branch ${BRANCH}. Please specify ENVIRONMENT parameter.")
                    }
                    
                    env.DEPLOY_ENVIRONMENT = environment
                    echo "‚úÖ Final DEPLOY_ENVIRONMENT: ${env.DEPLOY_ENVIRONMENT}"
                    
                    // Modular: Cluster name can be per-environment or shared
                    // For now: single cluster for all (modular for future: env.CLUSTER_NAME = "tnt-eu-chatapp-${environment}-eks")
                    // Current: uses shared cluster name from environment block
                    
                    // Read deployment manifest
                    def deploymentFile = "deployments/${environment}/deployment.yaml"
                    
                    if (!fileExists(deploymentFile)) {
                        error("Deployment manifest not found: ${deploymentFile}. Ensure CI has run and updated the manifest.")
                    }
                    
                    // Parse deployment.yaml
                    def manifestContent = readFile deploymentFile
                    def manifest = [:]
                    
                    // Simple YAML parsing (basic key: value format)
                    manifestContent.split('\n').each { line ->
                        def trimmed = line.trim()
                        if (trimmed && !trimmed.startsWith('#') && trimmed.contains(':')) {
                            def parts = trimmed.split(':', 2)
                            if (parts.length == 2) {
                                def key = parts[0].trim()
                                def value = parts[1].trim().replaceAll(/^["']|["']$/, '')
                                // Skip "null" values and empty strings
                                if (value != 'null' && !value.isEmpty() && value != '""' && value != "''") {
                                    manifest[key] = value
                                }
                            }
                        }
                    }
                    
                    // Debug: Show parsed manifest
                    echo "üìã Parsed manifest keys: ${manifest.keySet()}"
                    echo "üìã Full manifest content: ${manifest}"
                    if (manifest.ecr_registry) {
                        echo "‚úÖ Found ecr_registry in manifest: ${manifest.ecr_registry}"
                    } else {
                        echo "‚ö†Ô∏è  ecr_registry not found in manifest"
                    }
                    if (manifest.backend_image) {
                        echo "‚úÖ Found backend_image in manifest: ${manifest.backend_image}"
                    } else {
                        echo "‚ö†Ô∏è  backend_image not found in manifest"
                    }
                    if (manifest.frontend_image) {
                        echo "‚úÖ Found frontend_image in manifest: ${manifest.frontend_image}"
                    } else {
                        echo "‚ö†Ô∏è  frontend_image not found in manifest"
                    }
                    
                    // Set version and registry from manifest (or override from parameters)
                    if (params.IMAGE_VERSION && !params.IMAGE_VERSION.isEmpty()) {
                        env.DEPLOY_VERSION = params.IMAGE_VERSION
                        echo "‚ö†Ô∏è  Using override version: ${env.DEPLOY_VERSION}"
                    } else if (manifest.version && !manifest.version.isEmpty()) {
                        env.DEPLOY_VERSION = manifest.version
                        echo "‚úÖ Using version from manifest: ${env.DEPLOY_VERSION}"
                    } else {
                        error("No version found in deployment manifest and no override provided.")
                    }
                    
                    // Set ECR_REGISTRY from manifest (simple and direct)
                    if (params.ECR_REGISTRY_PARAM && !params.ECR_REGISTRY_PARAM.isEmpty()) {
                        env.ECR_REGISTRY = params.ECR_REGISTRY_PARAM.trim()
                    } else if (manifest.ecr_registry) {
                        env.ECR_REGISTRY = manifest.ecr_registry.trim()
                    }
                    
                    if (env.ECR_REGISTRY) {
                        echo "‚úÖ ECR_REGISTRY: ${env.ECR_REGISTRY}"
                    }
                    
                    // Get ECR repo
                    def ecrRepo = manifest.ecr_repo ?: ECR_REPO
                    
                    // Use full image paths from manifest if available (preferred), otherwise construct
                    if (manifest.backend_image && !manifest.backend_image.isEmpty() && !manifest.backend_image.contains('null')) {
                        env.BACKEND_IMAGE = manifest.backend_image.trim()
                        echo "‚úÖ Using backend_image from manifest: ${env.BACKEND_IMAGE}"
                    } else {
                        env.BACKEND_IMAGE = "${env.ECR_REGISTRY}:backend-${env.DEPLOY_VERSION}"
                        echo "‚ö†Ô∏è  Constructed backend_image (manifest not available): ${env.BACKEND_IMAGE}"
                    }
                    
                    if (manifest.frontend_image && !manifest.frontend_image.isEmpty() && !manifest.frontend_image.contains('null')) {
                        env.FRONTEND_IMAGE = manifest.frontend_image.trim()
                        echo "‚úÖ Using frontend_image from manifest: ${env.FRONTEND_IMAGE}"
                    } else {
                        env.FRONTEND_IMAGE = "${env.ECR_REGISTRY}:frontend-${env.DEPLOY_VERSION}"
                        echo "‚ö†Ô∏è  Constructed frontend_image (manifest not available): ${env.FRONTEND_IMAGE}"
                    }
                    
                    echo """
                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë  DEPLOYMENT INFORMATION                 ‚ïë
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    Environment:  ${env.DEPLOY_ENVIRONMENT}
                    Version:      ${env.DEPLOY_VERSION}
                    ECR Registry: ${env.ECR_REGISTRY}
                    ECR Repo:     ${ecrRepo}
                    Backend:      ${env.BACKEND_IMAGE}
                    Frontend:     ${env.FRONTEND_IMAGE}
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    """.stripIndent()
                }
            }
        }

        stage('Authenticate to AWS') {
            steps {
                script {
                    logMessage('Authenticating to AWS', 'üîê')
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            aws sts get-caller-identity
                            echo "‚úÖ AWS authenticated"
                        """
                    }
                }
            }
        }

        stage('Configure Kubeconfig') {
            steps {
                script {
                    logMessage('Configuring kubectl for EKS cluster', '‚öôÔ∏è')
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            echo "üîß Updating kubeconfig for cluster: ${CLUSTER_NAME}"
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                            
                            echo "‚úÖ Verifying cluster access..."
                            #kubectl cluster-info
                            kubectl get nodes
                        """
                    }
                }
            }
        }

        stage('Approve Production Deployment') {
            when {
                expression { env.DEPLOY_ENVIRONMENT == 'prod' }
            }
            steps {
                script {
                    logMessage('Production Deployment Approval Required', 'üö®')
                    
                    def approval = input(
                        message: "üö® Deploy ${env.DEPLOY_VERSION} to PRODUCTION?",
                        ok: 'Deploy to Production',
                        parameters: [
                            string(
                                name: 'DEPLOYMENT_REASON',
                                description: 'Why are you deploying to production?'
                            )
                        ]
                    )
                    
                    env.DEPLOYMENT_REASON = approval.DEPLOYMENT_REASON ?: 'No reason provided'
                    echo "‚úÖ Production deployment approved"
                    echo "Reason: ${env.DEPLOYMENT_REASON}"
                }
            }
        }

        stage('Helm Deploy Application') {
            steps {
                script {
                    logMessage('Deploying application via Helm', 'üöÄ')
                    
                    
                    if (!env.DEPLOY_VERSION || env.DEPLOY_VERSION.isEmpty()) {
                        error("DEPLOY_VERSION is not set! Check deployment manifest or provide IMAGE_VERSION.")
                    }
                    
                    def namespace = "chatapp-${env.DEPLOY_ENVIRONMENT}"
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                            sh """
                                echo "üì¶ Deploying with Helm..."
                                echo "Environment: ${env.DEPLOY_ENVIRONMENT}"
                                echo "Namespace: ${namespace}"
                                echo "Current directory: \$(pwd)"
                                echo "Chart location: helm-chart/"
                                ls -la helm-chart/ || echo "‚ö†Ô∏è  helm-chart not found in current directory"
                                echo ""
                                echo "üîç DEBUG - Image variables from Groovy:"
                                echo "  BACKEND_IMAGE env var: ${env.BACKEND_IMAGE}"
                                echo "  FRONTEND_IMAGE env var: ${env.FRONTEND_IMAGE}"
                                echo ""
                                
                                # Verify variables are not empty
                                BACKEND_IMG="${env.BACKEND_IMAGE}"
                                FRONTEND_IMG="${env.FRONTEND_IMAGE}"
                                
                                echo "üîç DEBUG - Image variables in shell:"
                                echo "  BACKEND_IMG: \${BACKEND_IMG}"
                                echo "  FRONTEND_IMG: \${FRONTEND_IMG}"
                                echo ""
                                
                                if [ -z "\$BACKEND_IMG" ] || [ -z "\$FRONTEND_IMG" ]; then
                                    echo "‚ùå BACKEND_IMAGE or FRONTEND_IMAGE is empty! Cannot deploy."
                                    exit 1
                                fi
                                
                                # Extract repository and tag from full image paths
                                # Format: {registry}/{repo}:{component}-{version}
                                BACKEND_REPO=\$(echo "\$BACKEND_IMG" | cut -d: -f1)
                                BACKEND_TAG=\$(echo "\$BACKEND_IMG" | cut -d: -f2)
                                FRONTEND_REPO=\$(echo "\$FRONTEND_IMG" | cut -d: -f1)
                                FRONTEND_TAG=\$(echo "\$FRONTEND_IMG" | cut -d: -f2)
                                
                                echo "Backend:  \${BACKEND_REPO}:\${BACKEND_TAG}"
                                echo "Frontend: \${FRONTEND_REPO}:\${FRONTEND_TAG}"
                                
                                # Use environment-specific values file (Helm best practice)
                                VALUES_FILE="values-${env.DEPLOY_ENVIRONMENT}.yaml"
                                echo "üìã Using values file: \${VALUES_FILE}"
                                
                                helm upgrade --install chatapp ./helm-chart \\
                                    --namespace ${namespace} \\
                                    --create-namespace \\
                                    -f ./helm-chart/\${VALUES_FILE} \\
                                    --set backend.image.repository=\${BACKEND_REPO} \\
                                    --set backend.image.tag=\${BACKEND_TAG} \\
                                    --set frontend.image.repository=\${FRONTEND_REPO} \\
                                    --set frontend.image.tag=\${FRONTEND_TAG} \\
                                    --set backend.monitoring.enabled=false \\
                                    --set backend.secretsProvider.enabled=true \\
                                    --set backend.secretsProvider.className=chatapp-secrets \\
                                    --wait \\
                                    --timeout 10m
                                
                                echo "‚úÖ Helm deployment completed"
                            """
                    }
                }
            }
        }

        stage('Post-Deployment Smoke Tests') {
            steps {
                script {
                    logMessage('Running Post-Deployment Smoke Tests', 'üî¨')
                    
                    def namespace = "chatapp-${env.DEPLOY_ENVIRONMENT}"
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            CLUSTER="${CLUSTER_NAME}"
                            echo "Environment: ${env.DEPLOY_ENVIRONMENT}"
                            echo "Version: ${env.DEPLOY_VERSION}"
                            echo "Namespace: ${namespace}"
                            echo "Cluster: \$CLUSTER"
                            echo ""
                            
                            echo "üîç Checking deployment status..."
                            kubectl rollout status deployment/chatapp-backend -n ${namespace} --timeout=5m || true
                            kubectl rollout status deployment/chatapp-frontend -n ${namespace} --timeout=5m || true
                            
                            echo ""
                            echo "üìä Checking pod status..."
                            kubectl get pods -n ${namespace}
                            
                            echo ""
                            echo "üåê Checking services..."
                            kubectl get svc -n ${namespace}
                            
                            echo ""
                            echo "üî¨ Running health check..."
                            # Port-forward to backend and test health endpoint
                            kubectl port-forward -n ${namespace} svc/chatapp-backend 5000:5000 &
                            PF_PID=\$!
                            sleep 5
                            
                            if curl -f http://localhost:5000/health; then
                                echo "‚úÖ Backend health check passed"
                                kill \$PF_PID || true
                            else
                                echo "‚ùå Backend health check failed"
                                kill \$PF_PID || true
                                exit 1
                            fi
                            
                            echo ""
                            echo "‚úÖ All smoke tests passed"
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                logMessage('CD Pipeline Completed', 'üìä')
            }
        }
        success {
            script {
                logMessage('CD Pipeline Completed Successfully!', '‚úÖ')
            }
        }
        failure {
            script {
                logMessage('CD Pipeline Failed!', '‚ùå')
            }
        }
    }
}

