@Library('jenkins-shared-library') _

pipeline {
    agent {
        docker {
            image 'python:3.9'
            args '-v /var/run/docker.sock:/var/run/docker.sock -u root'
        }
    }

    // Pipeline Options
    options {
        timeout(time: 1, unit: 'HOURS')                    // Kill pipeline after 1 hour
        timestamps()                                        // Add timestamps to console output
        buildDiscarder(logRotator(numToKeepStr: '10'))     // Keep only last 10 builds
        disableConcurrentBuilds()                          // Don't run multiple builds at once
    }

    // User Parameters - COMMENTED OUT (not needed for now)
    // parameters {
    //     booleanParam(
    //         name: 'SKIP_TESTS',
    //         defaultValue: false,
    //         description: 'Skip test stages (emergency use only)'
    //     )
    //     booleanParam(
    //         name: 'PUSH_TO_REGISTRY',
    //         defaultValue: true,
    //         description: 'Push images to Docker Hub'
    //     )
    // }

    // Environment Variables (Available in all stages)
    environment {
        // AWS Configuration
        AWS_REGION = 'eu-central-1'
        AWS_CREDENTIALS_ID = 'aws-creds'                // Jenkins AWS credentials ID
        CLUSTER_NAME = 'tnt-eu-observability-dev-eks'    // EKS cluster name (from Terraform)
        
        // Docker Hub Configuration (legacy, will be replaced by ECR)
        DOCKER_REGISTRY = 'tomernos'                    // Your Docker Hub username
        DOCKER_CREDENTIALS_ID = 'dockerhubauth'         // Must match Jenkins credential ID
        
        // GitHub credential (username + PAT for HTTPS push)
        GIT_CREDENTIALS_ID = 'gitpat'                   // GitHub PAT credential
        
        
        // ============================================================
        // SEMANTIC VERSIONING STRATEGY (Automated Tags)
        // ============================================================
        // Every commit gets a semantic version tag:
        //   main     ‚Üí v2.1.1 (production release)
        //   staging  ‚Üí v2.1.2-rc.1 (release candidate)
        //   develop  ‚Üí v2.2.0-dev.1 (development)
        //
        // Commit message conventions (Conventional Commits):
        //   - "feat: ..." ‚Üí MINOR bump
        //   - "fix: ..." ‚Üí PATCH bump 
        //   - "BREAKING CHANGE:" ‚Üí MAJOR bump 
        //
        // Jenkins automatically provides:
        //   - BRANCH_NAME: Branch name (e.g., "develop", "main")
        //   - GIT_BRANCH: Full branch path (e.g., "origin/main")
        //   - GIT_COMMIT: Full commit hash
        
        // Get short commit hash (first 7 characters)
        GIT_SHORT_COMMIT = "${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        
        // Detect which branch we're on (normalize branch name)
        BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH?.replaceAll('origin/', '') ?: 'unknown'}"
        
        // Image Names (Full paths for Docker Hub - legacy)
        BACKEND_IMAGE = "${DOCKER_REGISTRY}/connecthub-backend"
        FRONTEND_IMAGE = "${DOCKER_REGISTRY}/connecthub-frontend"
        
        // ECR Registry (will be set after AWS auth)
        ECR_REGISTRY = ''
        ECR_BACKEND_REPO = 'connecthub-backend'
        ECR_FRONTEND_REPO = 'connecthub-frontend'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Calculate & Create Version Tag') {
            steps {
                script {
                    logMessage('Auto-calculating Semantic Version', 'üè∑Ô∏è')
                    
                    // Simple version calculation based on branch
                    def versionInfo = calculateAndCreateTag(
                        branch: BRANCH,
                        gitCredentialsId: GIT_CREDENTIALS_ID
                    )
                    
                    // Store version in environment variable
                    env.VERSION = versionInfo.version
                    env.PREVIOUS_VERSION = versionInfo.previousVersion
                    env.BUMP_TYPE = versionInfo.bumpType
                    env.IS_RELEASE = versionInfo.isRelease.toString()
                    env.TARGET_ENVIRONMENT = versionInfo.environment
                    
                    echo """
                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë  VERSION INFORMATION                   ‚ïë
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    Branch:           ${BRANCH}
                    Previous Version: ${env.PREVIOUS_VERSION}
                    New Version:      ${env.VERSION}
                    Bump Type:        ${env.BUMP_TYPE}
                    Environment:      ${env.TARGET_ENVIRONMENT}
                    Is Release:       ${env.IS_RELEASE}
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    """.stripIndent()
                }
            }
        }

        stage('Setup Dependencies') {
            steps {
                script {
                    logMessage('Installing System Dependencies', 'üì¶')
                    
                    // Install basic packages
                    installDependencies(['curl', 'gnupg', 'lsb-release', 'ca-certificates'])
                    
                    // Install Docker CLI and Compose v2 (auto-detects debian)
                    def composeInfo = installDockerCompose()
                    
                    echo "Docker Compose version: ${composeInfo.version}"
                    echo "Command to use: ${composeInfo.command}"
                    
                    // Install Python packages (suppress root warnings in CI)
                    sh '''
                        pip3 install --quiet --upgrade pip --root-user-action=ignore
                        pip3 install --quiet -r backend-service/requirements.txt --root-user-action=ignore
                        pip3 install --quiet pytest --root-user-action=ignore
                    '''
                    
                    logMessage('All dependencies installed', '‚úÖ')
                }
            }
        }

        stage('Python Tests') {
            // when {
            //     expression { !params.SKIP_TESTS }
            // }
            steps {
                script {
                    logMessage('Running Python Tests', 'üß™')
                    
                    sh '''
                        cd backend-service
                        pytest tests/ --verbose || echo "‚ö†Ô∏è  No tests yet"
                    '''
                }
            }
        }

        stage('Build Docker Images') {
            parallel {
                stage('Build Backend') {
                    steps {
                        script {
                            logMessage('Building Backend Docker Image', 'üî®')
                            
                            sh 'docker rmi connecthub-backend:latest tomernos/connecthub-backend:latest || true'
                            sh 'docker rmi connecthub-frontend:latest tomernos/connecthub-frontend:latest || true'

                            // Use shared library function to save artifact
                            def backendImage = dockerBuild(
                                imageName: 'connecthub-backend',
                                tag: 'latest',
                                context: './backend-service',
                                dockerfile: './backend-service/Dockerfile'
                            )
                            
                            saveDockerImage(
                                imageName: backendImage.imageName,
                                tag: backendImage.tag,
                                outputFile: 'backend.tar.gz'
                            )
                        }
                    }
                }
                
                stage('Build Frontend') {
                    steps {
                        script {
                            logMessage('Building Frontend Docker Image', 'üåê')
                            
                            // Use shared library function to save artifact
                            def frontendImage = dockerBuild(
                                imageName: 'connecthub-frontend',
                                tag: 'latest',
                                context: './frontend-service',
                                dockerfile: './frontend-service/Dockerfile'
                            )
                            
                            saveDockerImage(
                                imageName: frontendImage.imageName,
                                tag: frontendImage.tag,
                                outputFile: 'frontend.tar.gz'
                            )
                        }
                    }
                }
            }
        }

        stage('Tag Images') {
            steps {
                script {
                    logMessage('Tagging Images for docker-compose', 'üè∑Ô∏è')
                    
                    sh '''
                        docker tag connecthub-backend:latest tomernos/connecthub-backend:latest
                        docker tag connecthub-frontend:latest tomernos/connecthub-frontend:latest
                        docker images | grep connecthub
                    '''
                }
            }
        }

        stage('Start Services') {
            steps {
                script {
                    logMessage('Starting Services with docker-compose', 'üöÄ')
                    
                    sh '''
                        # Force cleanup ALL containers with these names
                        docker ps -a | grep -E "connecthub-|chatapplication" | awk '{print $1}' | xargs -r docker rm -f || true
                        
                        # Cleanup compose resources
                        docker compose down -v 2>/dev/null || true
                        
                        # Start services
                        docker compose up -d
                        
                        # Show status
                        docker compose ps

                        docker logs connecthub-backend-api
                    '''
                }
            }
        }

        stage('Integration Health Checks Test') {
            steps {
                script {
                    logMessage('Waiting for Services to be Healthy', '‚è≥')
                
                    
                    // Use shared library function for backend
                    def backendHealthy = waitForService(
                        serviceName: 'Backend API',
                        healthCheckCmd: 'docker exec connecthub-backend-api curl -f http://localhost:5000/health 2>/dev/null',
                        maxRetries: 3,
                        waitSeconds: 5
                    )
                    
                    if (!backendHealthy) {
                        sh 'docker logs connecthub-backend-api'
                        error('Backend health check failed!')
                    }
                    
                    def frontendHealthy = waitForService(
                        serviceName: 'Frontend Web',
                        healthCheckCmd: 'docker exec connecthub-frontend-web curl -f http://localhost:80 2>/dev/null',
                        maxRetries: 3,
                        waitSeconds: 5
                    )
                    
                    if (!frontendHealthy) {
                        sh 'docker logs connecthub-frontend-web'
                        error('Frontend health check failed!')
                    }
                }
            }
        }

        stage('Archive Artifacts') {
            steps {
                script {
                    logMessage('Archiving Artifacts', 'üíæ')
                    
                    // Create manifest with version info
                    sh """
                            cat > artifacts/manifest.json << EOF
                            {
                            "version": "${env.VERSION}",
                            "environment": "${env.TARGET_ENVIRONMENT}",
                            "is_release": "${env.IS_RELEASE}",
                            "git_commit": "${env.GIT_COMMIT}",
                            "git_short_commit": "${GIT_SHORT_COMMIT}",
                            "git_branch": "${env.GIT_BRANCH}",
                            "git_tag": "${env.TAG_NAME ?: 'none'}",
                            "build_url": "${env.BUILD_URL}",
                            "timestamp": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                            "images": {
                                "backend": "${BACKEND_IMAGE}:${env.VERSION}",
                                "frontend": "${FRONTEND_IMAGE}:${env.VERSION}"
                            }
                            }
                            EOF
                        """
                    
                    // Archive using Jenkins plugin
                    archiveArtifacts artifacts: 'artifacts/*', 
                                   fingerprint: true,
                                   allowEmptyArchive: false
                    
                    logMessage('Artifacts archived successfully', '‚úÖ')
                }
            }
        }

        // ===========================================
        // DOCKER HUB PUSH - COMMENTED OUT
        // ===========================================
        // stage('Push to Docker Hub') {
        //     when {
        //         allOf {
        //             expression { params.PUSH_TO_REGISTRY }
                    
        //             expression {
        //                 def branch = env.BRANCH
        //                 return branch ==~ /.*main$/ || 
        //                        branch ==~ /.*staging$/ || 
        //                        branch ==~ /.*develop$/
        //             }
        //         }
        //     }
        //     steps {
        //         script {
        //             logMessage("Pushing Images to Docker Hub", 'üì§')
                    
        //                     echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        //                     echo "üì¶ BUILD INFORMATION"
        //                     echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        //                     echo "Version:      ${env.VERSION}"
        //                     echo "Environment:  ${env.TARGET_ENVIRONMENT}"
        //                     echo "Is Release:   ${env.IS_RELEASE}"
        //                     echo "Git Tag:      ${env.TAG_NAME ?: 'none'}"
        //                     echo "Git Commit:   ${GIT_SHORT_COMMIT}"
        //                     echo "Branch:       ${BRANCH}"
        //                     echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        //                     echo ""
        //                     
        //                     // Use Jenkins credentials securely
        //                     withCredentials([usernamePassword(
        //                         credentialsId: "${DOCKER_CREDENTIALS_ID}",
        //                         usernameVariable: 'DOCKER_USER',
        //                         passwordVariable: 'DOCKER_PASS'
        //                     )]) {
        //                         sh """
        //                             echo "üîê Logging into Docker Hub as: \$DOCKER_USER"
        //                             echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin
        //                             
        //                             echo ""
        //                             echo "üè∑Ô∏è  Tagging images with version: ${env.VERSION}"
        //                             
        //                             # Tag backend with version
        //                             docker tag connecthub-backend:latest ${BACKEND_IMAGE}:${env.VERSION}
        //                             echo "‚úÖ Tagged: ${BACKEND_IMAGE}:${env.VERSION}"
        //                             
        //                             # Tag frontend with version
        //                             docker tag connecthub-frontend:latest ${FRONTEND_IMAGE}:${env.VERSION}
        //                             echo "‚úÖ Tagged: ${FRONTEND_IMAGE}:${env.VERSION}"
        //                             
        //                             echo ""
        //                             echo "üì§ Pushing versioned images to Docker Hub..."
        //                             
        //                             # Push backend
        //                             docker push ${BACKEND_IMAGE}:${env.VERSION}
        //                             echo "‚úÖ Pushed: ${BACKEND_IMAGE}:${env.VERSION}"
        //                             
        //                             # Push frontend
        //                             docker push ${FRONTEND_IMAGE}:${env.VERSION}
        //                             echo "‚úÖ Pushed: ${FRONTEND_IMAGE}:${env.VERSION}"
        //                             
        //                             echo ""
        //                             echo "ÔøΩ Logging out from Docker Hub"
        //                             docker logout
        //                             
        //                             echo ""
        //                             echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        //                             echo "‚úÖ IMAGES PUBLISHED TO DOCKER HUB"
        //                             echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        //                             echo "Version: ${env.VERSION}"
        //                             echo "Backend:  ${BACKEND_IMAGE}:${env.VERSION}"
        //                             echo "Frontend: ${FRONTEND_IMAGE}:${env.VERSION}"
        //                             echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        //                         """
        //                     }
        //             
        //             echo ""
        //             echo "View on Docker Hub:"
        //             echo "  Backend:  https://hub.docker.com/r/${DOCKER_REGISTRY}/connecthub-backend/tags"
        //             echo "  Frontend: https://hub.docker.com/r/${DOCKER_REGISTRY}/connecthub-frontend/tags"
        //         }
        //     }
        // }

        // ===========================================
        // AWS INFRASTRUCTURE & DEPLOYMENT STAGES
        // ===========================================

        stage('Authenticate to AWS & Set ECR Registry') {
            when {
                expression {
                    def branch = env.BRANCH
                    return branch ==~ /.*main$/ || 
                           branch ==~ /.*staging$/ || 
                           branch ==~ /.*develop$/
                }
            }
            steps {
                script {
                    logMessage('Authenticating to AWS and setting ECR registry', 'üîê')
                    
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: AWS_CREDENTIALS_ID,
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        // Install AWS CLI if not available
                        sh '''
                            set -e
                            if ! command -v aws &> /dev/null; then
                                echo "üì¶ Installing AWS CLI..."
                                apt-get update -qq
                                apt-get install -y -qq curl unzip
                                curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                unzip -q awscliv2.zip
                                ./aws/install
                                rm -rf awscliv2.zip aws
                                echo "‚úÖ AWS CLI installed"
                            else
                                echo "‚úÖ AWS CLI already installed"
                                aws --version
                            fi
                        '''
                        
                        // Verify AWS credentials are set
                        sh '''
                            if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
                                echo "‚ùå AWS credentials not set!"
                                exit 1
                            fi
                            echo "‚úÖ AWS credentials are set"
                        '''
                        
                        // Get AWS account ID and set ECR registry
                        echo "üîç Getting AWS account ID..."
                        def accountId = sh(
                            script: 'aws sts get-caller-identity --query Account --output text 2>&1',
                            returnStdout: true
                        ).trim()
                        
                        if (accountId.isEmpty() || accountId.contains("error") || accountId.contains("Unable")) {
                            error("Failed to get AWS account ID. Response: ${accountId}. Check AWS credentials.")
                        }
                        
                        env.AWS_ACCOUNT_ID = accountId
                        env.ECR_REGISTRY = "${accountId}.dkr.ecr.${AWS_REGION}.amazonaws.com"
                        
                        echo "‚úÖ AWS authenticated successfully"
                        echo "Account ID: ${accountId}"
                        echo "Region: ${AWS_REGION}"
                        echo "ECR Registry: ${env.ECR_REGISTRY}"
                        
                        // Verify ECR registry is set
                        if (!env.ECR_REGISTRY || env.ECR_REGISTRY.isEmpty()) {
                            error("ECR_REGISTRY is not set! Cannot proceed with ECR operations.")
                        }
                    }
                }
            }
        }

        stage('Push to ECR') {
            when {
                expression {
                    def branch = env.BRANCH
                    return branch ==~ /.*main$/ || 
                           branch ==~ /.*staging$/ || 
                           branch ==~ /.*develop$/
                }
            }
            steps {
                script {
                    logMessage("Pushing Images to ECR", 'üì§')
                    
                    // Verify ECR_REGISTRY is set (from previous stage)
                    if (!env.ECR_REGISTRY || env.ECR_REGISTRY.isEmpty()) {
                        error("ECR_REGISTRY is not set! Run 'Authenticate to AWS' stage first.")
                    }
                    
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: AWS_CREDENTIALS_ID,
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        sh """
                            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                            echo "üì¶ BUILD INFORMATION"
                            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                            echo "Version:      ${env.VERSION}"
                            echo "Environment:  ${env.TARGET_ENVIRONMENT}"
                            echo "ECR Registry: ${env.ECR_REGISTRY}"
                            echo "Branch:       ${BRANCH}"
                            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                            echo ""
                            
                            # Login to ECR
                            echo "üîê Logging into ECR..."
                            aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${env.ECR_REGISTRY}
                            
                            if [ \$? -ne 0 ]; then
                                echo "‚ùå ECR login failed"
                                exit 1
                            fi
                            
                            # Ensure ECR repositories exist (create if missing)
                            echo "üì¶ Ensuring ECR repositories exist..."
                            aws ecr describe-repositories --repository-names ${ECR_BACKEND_REPO} --region ${AWS_REGION} 2>/dev/null || \\
                                aws ecr create-repository --repository-name ${ECR_BACKEND_REPO} --region ${AWS_REGION} || true
                            
                            aws ecr describe-repositories --repository-names ${ECR_FRONTEND_REPO} --region ${AWS_REGION} 2>/dev/null || \\
                                aws ecr create-repository --repository-name ${ECR_FRONTEND_REPO} --region ${AWS_REGION} || true
                            
                            echo ""
                            echo "üè∑Ô∏è  Tagging images with ECR paths..."
                            
                            # Tag backend with ECR path
                            docker tag connecthub-backend:latest ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.VERSION}
                            docker tag connecthub-backend:latest ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:latest
                            echo "‚úÖ Tagged: ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.VERSION}"
                            
                            # Tag frontend with ECR path
                            docker tag connecthub-frontend:latest ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.VERSION}
                            docker tag connecthub-frontend:latest ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:latest
                            echo "‚úÖ Tagged: ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.VERSION}"
                            
                            echo ""
                            echo "üì§ Pushing images to ECR..."
                            
                            # Push backend
                            docker push ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.VERSION}
                            docker push ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:latest
                            echo "‚úÖ Pushed: ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.VERSION}"
                            
                            # Push frontend
                            docker push ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.VERSION}
                            docker push ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:latest
                            echo "‚úÖ Pushed: ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.VERSION}"
                            
                            echo ""
                            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                            echo "‚úÖ IMAGES PUBLISHED TO ECR"
                            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                            echo "Version: ${env.VERSION}"
                            echo "Backend:  ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.VERSION}"
                            echo "Frontend: ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.VERSION}"
                            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                        """
                    }
                }
            }
        }

        stage('Terraform Apply (Ensure Cluster)') {
            when {
                expression {
                    def branch = env.BRANCH
                    return branch ==~ /.*main$/ || 
                           branch ==~ /.*staging$/ || 
                           branch ==~ /.*develop$/
                }
            }
            steps {
                script {
                    logMessage('Ensuring EKS cluster exists via Terraform', 'üèóÔ∏è')
                    
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: AWS_CREDENTIALS_ID,
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        dir('Observability/infra-tf') {
                            sh """
                                echo "üîß Initializing Terraform..."
                                terraform init
                                
                                echo "üìã Running Terraform plan..."
                                terraform plan -out=tfplan
                                
                                echo "üöÄ Applying Terraform changes..."
                                terraform apply -auto-approve tfplan
                                
                                echo "‚úÖ Terraform apply completed"
                            """
                        }
                    }
                }
            }
        }

        stage('Configure Kubeconfig') {
            when {
                expression {
                    def branch = env.BRANCH
                    return branch ==~ /.*main$/ || 
                           branch ==~ /.*staging$/ || 
                           branch ==~ /.*develop$/
                }
            }
            steps {
                script {
                    logMessage('Configuring kubectl for EKS cluster', '‚öôÔ∏è')
                    
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: AWS_CREDENTIALS_ID,
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        sh """
                            echo "üîß Updating kubeconfig for cluster: ${CLUSTER_NAME}"
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                            
                            echo "‚úÖ Verifying cluster access..."
                            kubectl cluster-info
                            kubectl get nodes
                        """
                    }
                }
            }
        }

        stage('Helm Deploy Application') {
            when {
                expression {
                    def branch = env.BRANCH
                    return branch ==~ /.*main$/ || 
                           branch ==~ /.*staging$/ || 
                           branch ==~ /.*develop$/
                }
            }
            steps {
                script {
                    logMessage('Deploying application via Helm', 'üöÄ')
                    
                    // Verify ECR_REGISTRY is set (from Authenticate to AWS stage)
                    if (!env.ECR_REGISTRY || env.ECR_REGISTRY.isEmpty()) {
                        error("ECR_REGISTRY is not set! Run 'Authenticate to AWS' stage first.")
                    }
                    
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: AWS_CREDENTIALS_ID,
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        dir('ChatApplication') {
                            sh """
                                echo "üì¶ Deploying with Helm..."
                                echo "Chart: helm-chart/"
                                echo "Backend Image: ${env.ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.VERSION}"
                                echo "Frontend Image: ${env.ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.VERSION}"
                                
                                # Verify ECR_REGISTRY is not empty
                                ECR_REG="${env.ECR_REGISTRY}"
                                if [ -z "\$ECR_REG" ]; then
                                    echo "‚ùå ECR_REGISTRY is empty! Cannot deploy."
                                    exit 1
                                fi
                                
                                helm upgrade --install chatapp ./helm-chart \\
                                    --namespace chatapp-prod \\
                                    --create-namespace \\
                                    --set backend.image.repository=\${ECR_REG}/${ECR_BACKEND_REPO} \\
                                    --set backend.image.tag=${env.VERSION} \\
                                    --set frontend.image.repository=\${ECR_REG}/${ECR_FRONTEND_REPO} \\
                                    --set frontend.image.tag=${env.VERSION} \\
                                    --wait \\
                                    --timeout 10m
                                
                                echo "‚úÖ Helm deployment completed"
                            """
                        }
                    }
                 }
             }
         }

        // ===========================================
        // DEPLOYMENT STAGES (Automatic Branch-Based)
        // ===========================================

        stage('Deploy to Dev') {
            when {
                expression { BRANCH ==~ /.*develop$/ }
            }
            steps {
                script {
                    logMessage('Deployment completed via Helm Deploy stage', '‚úÖ')
                    echo "Environment: DEV"
                    echo "Version: ${env.VERSION}"
                    echo "Deployed via Helm to namespace: chatapp-prod"
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                expression { BRANCH ==~ /.*staging$/ }
            }
            steps {
                script {
                    logMessage('Deployment completed via Helm Deploy stage', '‚úÖ')
                    echo "Environment: STAGING"
                    echo "Version: ${env.VERSION}"
                    echo "Deployed via Helm to namespace: chatapp-prod"
                }
            }
        }

        stage('Approve Production Deployment') {
            when {
                expression { BRANCH ==~ /.*main$/ }
            }
            steps {
                script {
                    logMessage('Production Deployment Approval Required', 'üö®')
                    
                    // Manual admin approval 
                    timeout(time: 30, unit: 'MINUTES') {
                        input(
                            message: "üö® Deploy ${env.VERSION} to PRODUCTION?",
                            ok: 'Deploy to Production',
                            submitter: 'admin',  
                            parameters: [
                                string(
                                    name: 'DEPLOYMENT_REASON',
                                    defaultValue: '',
                                    description: 'Why are you deploying to production?'
                                ),
                                choice(
                                    name: 'ROLLBACK_PLAN',
                                    choices: ['Manual rollback prepared', 'Auto-rollback enabled'],
                                    description: 'Rollback strategy'
                                )
                            ]
                        )
                    }
                    
                    echo "‚úÖ Production deployment approved"
                    echo "Reason: ${DEPLOYMENT_REASON}"
                    echo "Rollback plan: ${ROLLBACK_PLAN}"
                }
            }
        }

        stage('Deploy to Production') {
            when {
                expression { BRANCH ==~ /.*main$/ }
            }
            steps {
                script {
                    logMessage('Deployment completed via Helm Deploy stage', '‚úÖ')
                    echo "Environment: PRODUCTION"
                    echo "Version: ${env.VERSION}"
                    echo "Deployed via Helm to namespace: chatapp-prod"
                    echo "üìß Production deployment notification sent"
                }
            }
        }

        stage('Post-Deployment Smoke Tests') {
            when {
                expression { 
                    BRANCH ==~ /.*develop$/ || 
                    BRANCH ==~ /.*staging$/ || 
                    BRANCH ==~ /.*main$/ 
                }
            }
            steps {
                script {
                    logMessage('Running Post-Deployment Smoke Tests', 'üî¨')
                    
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: AWS_CREDENTIALS_ID,
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        sh """
                            CLUSTER="${CLUSTER_NAME}"
                            echo "Environment: ${env.TARGET_ENVIRONMENT}"
                            echo "Version: ${env.VERSION}"
                            echo "Cluster: $CLUSTER"
                            echo ""
                            
                            echo "üîç Checking deployment status..."
                            kubectl rollout status deployment/chatapp-backend -n chatapp-prod --timeout=5m || true
                            kubectl rollout status deployment/chatapp-frontend -n chatapp-prod --timeout=5m || true
                            
                            echo ""
                            echo "üìä Checking pod status..."
                            kubectl get pods -n chatapp-prod
                            
                            echo ""
                            echo "üåê Checking services..."
                            kubectl get svc -n chatapp-prod
                            
                            echo ""
                            echo "üî¨ Running health check..."
                            # Port-forward to backend and test health endpoint
                            kubectl port-forward -n chatapp-prod svc/chatapp-backend 5000:5000 &
                            PF_PID=\$!
                            sleep 5
                            
                            if curl -f http://localhost:5000/health; then
                                echo "‚úÖ Backend health check passed"
                                kill \$PF_PID || true
                            else
                                echo "‚ùå Backend health check failed"
                                kill \$PF_PID || true
                                exit 1
                            fi
                            
                            echo ""
                            echo "‚úÖ All smoke tests passed"
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                logMessage('Cleanup', 'üßπ')
                
                sh '''
                    # Show logs if something failed
                    if [ $? -ne 0 ]; then
                        echo "=== Backend Logs ==="
                        docker logs connecthub-backend-api || true
                        echo ""
                        echo "=== Database Logs ==="
                        docker logs connecthub-database || true
                    fi
                    
                    # Always cleanup services
                    docker compose down -v || true
                    echo "‚úÖ Services stopped and cleaned"
                '''
            }
        }
        success {
            script {
                logMessage('CI Pipeline Completed Successfully!', '‚úÖ')
            }
        }
        failure {
            script {
                logMessage('CI Pipeline Failed!', '‚ùå')
            }
        }
    }
}