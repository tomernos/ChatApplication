@Library('jenkins-shared-library') _

// Helper function to update GitOps repository (must be defined outside pipeline block)
def updateGitOpsRepository(branch, ecrRegistry, timestamp, env, GITOPS_REPO_URL, GITOPS_REPO_PATH, APP_NAME, ECR_REPO, GIT_CREDENTIALS_ID) {
    // Determine environment from branch
    def envName = null
    def normalizedBranch = branch.replaceAll('origin/', '')
    
    if (normalizedBranch == 'develop') {
        envName = 'dev'
    } else if (normalizedBranch =~ /^release\//) {
        envName = 'staging'
    } else if (normalizedBranch == 'main' || normalizedBranch =~ /^hotfix\//) {
        envName = 'prod'
    }
    
    if (!envName) {
        return
    }
    
    // Clone GitOps repository
    withCredentials([usernamePassword(
        credentialsId: GIT_CREDENTIALS_ID,
        usernameVariable: 'GIT_USERNAME',
        passwordVariable: 'GIT_PASSWORD'
    )]) {
        sh """
            # Clone GitOps repo
            rm -rf ${GITOPS_REPO_PATH}
            git clone https://\${GIT_USERNAME}:\${GIT_PASSWORD}@github.com/tomernos/CompanyGitOps.git ${GITOPS_REPO_PATH}
            cd ${GITOPS_REPO_PATH}
            
            # Configure git
            git config user.name "Jenkins CI"
            git config user.email "jenkins@ci.local"
            
            # Create deployment manifest content
            cat > applications/${APP_NAME}/${envName}/deployment.yaml << 'DEPLOYMENT_EOF'
# Deployment Manifest - Auto-generated by CI
# Application: ${APP_NAME}
# Environment: ${envName}
# DO NOT manually edit - CI will overwrite changes
# Last updated: ${timestamp}

version: "${env.VERSION}"
ecr_registry: "${ecrRegistry}"
ecr_repo: "${ECR_REPO}"
backend_image: "${ecrRegistry}:backend-${env.VERSION}"
frontend_image: "${ecrRegistry}:frontend-${env.VERSION}"
deployed_at: "${timestamp}"
deployed_by: "jenkins"
git_commit: "${env.GIT_COMMIT}"
git_branch: "${normalizedBranch}"
DEPLOYMENT_EOF
            
            # Commit and push
            git add applications/${APP_NAME}/${envName}/deployment.yaml
            git commit -m "CI: Update ${APP_NAME} ${envName} to ${env.VERSION} [skip ci]" || exit 0
            git push origin main || true
        """
    }
}

pipeline {
    agent {
        docker {
            image 'python:3.9'
            args '-v /var/run/docker.sock:/var/run/docker.sock -u root'
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
    }

    environment {
        // AWS Configuration
        AWS_REGION = 'eu-central-1'
        AWS_CREDENTIALS_ID = 'aws-creds'
        
        // GitHub credential
        GIT_CREDENTIALS_ID = 'gitpat'
        
        // Docker Hub Configuration (legacy)
        DOCKER_REGISTRY = 'tomernos'
        DOCKER_CREDENTIALS_ID = 'dockerhubauth'
        
        // Get short commit hash
        GIT_SHORT_COMMIT = "${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        
        // Detect branch
        BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH?.replaceAll('origin/', '') ?: 'unknown'}"
        
        // Image Names
        BACKEND_IMAGE = "${DOCKER_REGISTRY}/connecthub-backend"
        FRONTEND_IMAGE = "${DOCKER_REGISTRY}/connecthub-frontend"
        
        // ECR Configuration
        AWS_ACCOUNT_ID = ''  // Set after AWS authentication
        ECR_REGISTRY_BASE = ''  // Format: {account_id}.dkr.ecr.{region}.amazonaws.com
        ECR_REPO = 'chatapp'  // Single ECR repository for both backend and frontend
        ECR_REGISTRY = ''  // Full registry URL: {ECR_REGISTRY_BASE}/{ECR_REPO}
        
        // GitOps Repository Configuration
        GITOPS_REPO_URL = 'https://github.com/tomernos/CompanyGitOps.git'
        GITOPS_REPO_PATH = '/tmp/gitops-repo'
        APP_NAME = 'chatapp'  // Application name in GitOps repo
    }

    stages {
        stage('Check Commit Message') {
            steps {
                script {
                    def commitMessage = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    
                    if (commitMessage.contains('[skip ci]') || commitMessage.contains('[ci skip]')) {
                        echo "â­ï¸  Skipping build - commit message contains [skip ci]"
                        currentBuild.result = 'ABORTED'
                        error("Build skipped due to [skip ci] in commit message")
                    }
                    
                    echo "âœ… Commit message check passed: ${commitMessage.take(50)}..."
                }
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Calculate & Create Version Tag') {
            steps {
                script {
                    logMessage('Auto-calculating Semantic Version', 'ðŸ·ï¸')
                    
                    def versionInfo = calculateAndCreateTag(
                        branch: BRANCH,
                        gitCredentialsId: GIT_CREDENTIALS_ID
                    )
                    
                    env.VERSION = versionInfo.version
                    env.PREVIOUS_VERSION = versionInfo.previousVersion
                    env.BUMP_TYPE = versionInfo.bumpType
                    env.IS_RELEASE = versionInfo.isRelease.toString()
                    env.TARGET_ENVIRONMENT = versionInfo.environment
                    
                    echo """
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘  VERSION INFORMATION                   â•‘
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Branch:           ${BRANCH}
                    Previous Version: ${env.PREVIOUS_VERSION}
                    New Version:      ${env.VERSION}
                    Bump Type:        ${env.BUMP_TYPE}
                    Environment:      ${env.TARGET_ENVIRONMENT}
                    Is Release:       ${env.IS_RELEASE}
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    """.stripIndent()
                }
            }
        }

        stage('Setup Dependencies') {
            steps {
                script {
                    logMessage('Installing System Dependencies', 'ðŸ“¦')
                    
                    installDependencies(['curl', 'gnupg', 'lsb-release', 'ca-certificates'])
                    
                    def composeInfo = installDockerCompose()
                    
                    echo "Docker Compose version: ${composeInfo.version}"
                    echo "Command to use: ${composeInfo.command}"
                    
                    sh '''
                        pip3 install --quiet --upgrade pip --root-user-action=ignore
                        pip3 install --quiet -r backend-service/requirements.txt --root-user-action=ignore
                        pip3 install --quiet pytest --root-user-action=ignore
                    '''
                    
                    logMessage('All dependencies installed', 'âœ…')
                }
            }
        }

        stage('Python Tests') {
            steps {
                script {
                    logMessage('Running Python Tests', 'ðŸ§ª')
                    
                    sh '''
                        cd backend-service
                        pytest tests/ --verbose || echo "âš ï¸  No tests yet"
                    '''
                }
            }
        }

        stage('Build Docker Images') {
            parallel {
                stage('Build Backend') {
                    steps {
                        script {
                            logMessage('Building Backend Docker Image', 'ðŸ”¨')
                            
                            sh 'docker rmi connecthub-backend:latest tomernos/connecthub-backend:latest || true'
                            sh 'docker rmi connecthub-frontend:latest tomernos/connecthub-frontend:latest || true'

                            def backendImage = dockerBuild(
                                imageName: 'connecthub-backend',
                                tag: 'latest',
                                context: './backend-service',
                                dockerfile: './backend-service/Dockerfile'
                            )
                            
                            saveDockerImage(
                                imageName: backendImage.imageName,
                                tag: backendImage.tag,
                                outputFile: 'backend.tar.gz'
                            )
                        }
                    }
                }
                
                stage('Build Frontend') {
                    steps {
                        script {
                            logMessage('Building Frontend Docker Image', 'ðŸŒ')
                            
                            def frontendImage = dockerBuild(
                                imageName: 'connecthub-frontend',
                                tag: 'latest',
                                context: './frontend-service',
                                dockerfile: './frontend-service/Dockerfile'
                            )
                            
                            saveDockerImage(
                                imageName: frontendImage.imageName,
                                tag: frontendImage.tag,
                                outputFile: 'frontend.tar.gz'
                            )
                        }
                    }
                }
            }
        }

        stage('Tag Images') {
            steps {
                script {
                    logMessage('Tagging Images', 'ðŸ·ï¸')
                    
                    sh '''
                        docker tag connecthub-backend:latest tomernos/connecthub-backend:latest
                        docker tag connecthub-frontend:latest tomernos/connecthub-frontend:latest
                        docker images | grep connecthub
                    '''
                }
            }
        }

        stage('Push to ECR') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'staging'  // Added: CI builds and pushes images for staging
                    branch 'main'
                    expression { env.BRANCH_NAME =~ /^release\// }
                    expression { env.BRANCH_NAME =~ /^hotfix\// }
                }
            }
            steps {
                script {
                    logMessage("Pushing Images to ECR", 'ðŸ“¤')
                    
                    // Get region
                    def region = env.AWS_REGION ?: 'eu-central-1'
                    
                    // Authenticate, get account ID, set ECR variables, and push - all in one withCredentials block
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        // Install AWS CLI if not available
                        sh '''
                            set -e
                            if ! command -v aws &> /dev/null; then
                                echo "ðŸ“¦ Installing AWS CLI..."
                                apt-get update -qq
                                apt-get install -y -qq curl unzip
                                
                                # Clean up any existing AWS CLI installations
                                rm -rf awscliv2.zip aws /usr/local/aws-cli /usr/local/bin/aws
                                
                                # Download and install AWS CLI non-interactively
                                curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                unzip -q -o awscliv2.zip
                                
                                # Install with explicit paths and update flag (non-interactive)
                                ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update 2>&1 | grep -v "replace" || true
                                
                                # Clean up
                                rm -rf awscliv2.zip aws
                                
                                # Verify installation
                                /usr/local/bin/aws --version
                                echo "âœ… AWS CLI installed"
                            else
                                echo "âœ… AWS CLI already installed"
                                aws --version
                            fi
                        '''
                        
                        // Get AWS account ID
                        def accountId = sh(
                            script: """
                                set -e
                                export AWS_DEFAULT_REGION=${region}
                                aws sts get-caller-identity --query Account --output text 2>/dev/null | grep -oE '[0-9]{12}' | head -n 1
                            """,
                            returnStdout: true
                        ).trim()
                        
                        if (!accountId || accountId.isEmpty()) {
                            error("Failed to get AWS account ID. Check AWS credentials and region.")
                        }
                        
                        // Calculate ECR registry values
                        def ecrRegistryBase = "${accountId}.dkr.ecr.${region}.amazonaws.com"
                        def ecrRegistry = "${ecrRegistryBase}/${ECR_REPO}"
                        
                        echo "âœ… AWS Configuration:"
                        echo "   Account ID: ${accountId}"
                        echo "   Region: ${region}"
                        echo "   ECR Registry: ${ecrRegistry}"
                        echo ""
                        sh """
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "ðŸ“¦ BUILD INFORMATION"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "Version:      ${env.VERSION}"
                            echo "Environment:  ${env.TARGET_ENVIRONMENT}"
                            echo "ECR Registry: ${ecrRegistry}"
                            echo "Branch:       ${BRANCH}"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo ""
                            
                            # Login to ECR
                            echo "ðŸ” Logging into ECR..."
                            aws ecr get-login-password --region ${region} | docker login --username AWS --password-stdin ${ecrRegistryBase}
                            
                            if [ \$? -ne 0 ]; then
                                echo "âŒ ECR login failed"
                                exit 1
                            fi
                            
                            # Verify ECR repository exists (created by Terraform)
                            echo "ðŸ“¦ Verifying ECR repository exists (created by Terraform)..."
                            REPO_CHECK=\$(aws ecr describe-repositories --repository-names ${ECR_REPO} --region ${region} 2>&1)
                            if [ \$? -ne 0 ]; then
                                echo "âš ï¸  Repository check output: \${REPO_CHECK}"
                                echo "âš ï¸  Attempting to continue anyway (repository might exist but check failed)..."
                            else
                                echo "âœ… ECR repository verified (created by Terraform)"
                            fi
                            echo ""
                            echo "ðŸ·ï¸  Tagging images with ECR paths..."
                            
                            # Tag backend (NO latest tag - ECR tags are immutable)
                            docker tag connecthub-backend:latest ${ecrRegistry}:backend-${env.VERSION}
                            echo "âœ… Tagged: ${ecrRegistry}:backend-${env.VERSION}"
                            
                            # Tag frontend (NO latest tag - ECR tags are immutable)
                            docker tag connecthub-frontend:latest ${ecrRegistry}:frontend-${env.VERSION}
                            echo "âœ… Tagged: ${ecrRegistry}:frontend-${env.VERSION}"
                            
                            echo ""
                            echo "ðŸ“¤ Pushing images to ECR..."
                            
                            # Push backend (versioned tag only)
                            docker push ${ecrRegistry}:backend-${env.VERSION}
                            echo "âœ… Pushed: ${ecrRegistry}:backend-${env.VERSION}"
                            
                            # Push frontend (versioned tag only)
                            docker push ${ecrRegistry}:frontend-${env.VERSION}
                            echo "âœ… Pushed: ${ecrRegistry}:frontend-${env.VERSION}"
                            
                            echo ""
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "âœ… IMAGES PUBLISHED TO ECR"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "Repository: ${ecrRegistry}"
                            echo "Version: ${env.VERSION}"
                            echo "Backend:  ${ecrRegistry}:backend-${env.VERSION}"
                            echo "Frontend: ${ecrRegistry}:frontend-${env.VERSION}"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                        """
                        
                        // Save values to file for next stage (simple solution)
                        sh """
                            echo "${ecrRegistry}" > /tmp/ecr_registry.txt
                            echo "${accountId}" > /tmp/aws_account_id.txt
                            echo "${ecrRegistryBase}" > /tmp/ecr_registry_base.txt
                        """
                        
                        // Set env variables for use in later stages
                        env.AWS_ACCOUNT_ID = accountId
                        env.ECR_REGISTRY_BASE = ecrRegistryBase
                        env.ECR_REGISTRY = ecrRegistry
                    }
                }
            }
        }

        stage('Update Deployment Manifest') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'staging'  // Added: CI runs on staging to update staging/deployment.yaml
                    branch 'main'
                    expression { env.BRANCH_NAME =~ /^release\// }
                    expression { env.BRANCH_NAME =~ /^hotfix\// }
                }
            }
            steps {
                script {
                    logMessage('Updating Deployment Manifest', 'ðŸ“')
                    
                    // Read ECR registry from file
                    def ecrRegistry = sh(
                        script: 'cat /tmp/ecr_registry.txt',
                        returnStdout: true
                    ).trim()
                    
                    if (!ecrRegistry || ecrRegistry.isEmpty()) {
                        error("ECR_REGISTRY not found in file! Make sure Push to ECR stage completed successfully.")
                    }
                    
                    // Get current timestamp
                    def timestamp = new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))
                    def normalizedBranch = BRANCH.replaceAll('origin/', '')
                    
                    // Update GitOps Repository
                    updateGitOpsRepository(normalizedBranch, ecrRegistry, timestamp, env, GITOPS_REPO_URL, GITOPS_REPO_PATH, APP_NAME, ECR_REPO, GIT_CREDENTIALS_ID)
                    
                    // Configure git and commit (with [skip ci] to prevent loop)
                    withCredentials([usernamePassword(
                        credentialsId: GIT_CREDENTIALS_ID,
                        usernameVariable: 'GIT_USERNAME',
                        passwordVariable: 'GIT_PASSWORD'
                    )]) {
                        sh """
                            # Configure git
                            git config user.name "Jenkins CI"
                            git config user.email "jenkins@ci.local"
                            
                            # Get the actual branch name (remove origin/ prefix if present)
                            ACTUAL_BRANCH=\$(echo ${env.BRANCH_NAME} | sed 's|origin/||')
                            if [ -z "\${ACTUAL_BRANCH}" ]; then
                                ACTUAL_BRANCH="${normalizedBranch}"
                            fi
                            
                            echo "ðŸ“ Branch for push: \${ACTUAL_BRANCH}"
                            
                            # Add deployment file
                            git add ${deploymentFile}
                            
                            # Check if there are changes to commit
                            if git diff --staged --quiet; then
                                echo "â„¹ï¸  No changes to deployment file (version unchanged)"
                            else
                                # Commit with [skip ci] to prevent infinite loop
                                # Jenkins should be configured to ignore commits with [skip ci] in message
                                git commit -m "CI: Update deployment manifest to ${env.VERSION} [skip ci]" || true
                                
                                # Push changes - use the actual branch name
                                git remote set-url origin https://\${GIT_USERNAME}:\${GIT_PASSWORD}@\$(echo ${env.GIT_URL} | sed -E 's|.*github.com[:/](.*)\\.git|github.com/\\1|' | sed 's|git@||')
                                
                                # Try to push, if it fails try with origin/ prefix
                                if ! git push origin \${ACTUAL_BRANCH} 2>&1; then
                                    echo "âš ï¸  First push attempt failed, trying with HEAD..."
                                    git push origin HEAD:\${ACTUAL_BRANCH} || echo "âš ï¸  Failed to push deployment manifest (may need manual push)"
                                fi
                                
                                echo "âœ… Deployment manifest updated and committed with [skip ci]"
                            fi
                        """
                    }
                }
            }
        }

        stage('Archive Artifacts') {
            steps {
                script {
                    logMessage('Archiving Artifacts', 'ðŸ’¾')
                    
                    sh """
                            cat > artifacts/manifest.json << EOF
                            {
                            "version": "${env.VERSION}",
                            "environment": "${env.TARGET_ENVIRONMENT}",
                            "is_release": "${env.IS_RELEASE}",
                            "git_commit": "${env.GIT_COMMIT}",
                            "git_short_commit": "${GIT_SHORT_COMMIT}",
                            "git_branch": "${env.GIT_BRANCH}",
                            "git_tag": "${env.TAG_NAME ?: 'none'}",
                            "build_url": "${env.BUILD_URL}",
                            "timestamp": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                            "images": {
                                "backend": "${env.ECR_REGISTRY}:backend-${env.VERSION}",
                                "frontend": "${env.ECR_REGISTRY}:frontend-${env.VERSION}"
                            }
                            }
                            EOF
                        """
                    
                    archiveArtifacts artifacts: 'artifacts/*', 
                                   fingerprint: true,
                                   allowEmptyArchive: false
                    
                    logMessage('Artifacts archived successfully', 'âœ…')
                }
            }
        }
    }

    post {
        always {
            script {
                logMessage('CI Pipeline Completed', 'ðŸ“Š')
            }
        }
        success {
            script {
                logMessage('CI Pipeline Completed Successfully!', 'âœ…')
            }
        }
        failure {
            script {
                logMessage('CI Pipeline Failed!', 'âŒ')
            }
        }
    }
}

