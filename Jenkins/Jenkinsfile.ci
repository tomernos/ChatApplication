@Library('jenkins-shared-library') _

pipeline {
    agent {
        docker {
            image 'python:3.9'
            args '-v /var/run/docker.sock:/var/run/docker.sock -u root'
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
    }

    environment {
        // AWS Configuration
        AWS_REGION = 'eu-central-1'
        AWS_CREDENTIALS_ID = 'aws-creds'
        
        // GitHub credential
        GIT_CREDENTIALS_ID = 'gitpat'
        
        // Docker Hub Configuration (legacy)
        DOCKER_REGISTRY = 'tomernos'
        DOCKER_CREDENTIALS_ID = 'dockerhubauth'
        
        // Get short commit hash
        GIT_SHORT_COMMIT = "${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        
        // Detect branch
        BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH?.replaceAll('origin/', '') ?: 'unknown'}"
        
        // Image Names
        BACKEND_IMAGE = "${DOCKER_REGISTRY}/connecthub-backend"
        FRONTEND_IMAGE = "${DOCKER_REGISTRY}/connecthub-frontend"
        
        // ECR Registry (will be set after AWS auth)
        ECR_REGISTRY = ''
        ECR_REPO = 'chatapp'  // Single ECR repository for both backend and frontend
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Calculate & Create Version Tag') {
            steps {
                script {
                    logMessage('Auto-calculating Semantic Version', 'ðŸ·ï¸')
                    
                    def versionInfo = calculateAndCreateTag(
                        branch: BRANCH,
                        gitCredentialsId: GIT_CREDENTIALS_ID
                    )
                    
                    env.VERSION = versionInfo.version
                    env.PREVIOUS_VERSION = versionInfo.previousVersion
                    env.BUMP_TYPE = versionInfo.bumpType
                    env.IS_RELEASE = versionInfo.isRelease.toString()
                    env.TARGET_ENVIRONMENT = versionInfo.environment
                    
                    echo """
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘  VERSION INFORMATION                   â•‘
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Branch:           ${BRANCH}
                    Previous Version: ${env.PREVIOUS_VERSION}
                    New Version:      ${env.VERSION}
                    Bump Type:        ${env.BUMP_TYPE}
                    Environment:      ${env.TARGET_ENVIRONMENT}
                    Is Release:       ${env.IS_RELEASE}
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    """.stripIndent()
                }
            }
        }

        stage('Setup Dependencies') {
            steps {
                script {
                    logMessage('Installing System Dependencies', 'ðŸ“¦')
                    
                    installDependencies(['curl', 'gnupg', 'lsb-release', 'ca-certificates'])
                    
                    def composeInfo = installDockerCompose()
                    
                    echo "Docker Compose version: ${composeInfo.version}"
                    echo "Command to use: ${composeInfo.command}"
                    
                    sh '''
                        pip3 install --quiet --upgrade pip --root-user-action=ignore
                        pip3 install --quiet -r backend-service/requirements.txt --root-user-action=ignore
                        pip3 install --quiet pytest --root-user-action=ignore
                    '''
                    
                    logMessage('All dependencies installed', 'âœ…')
                }
            }
        }

        stage('Python Tests') {
            steps {
                script {
                    logMessage('Running Python Tests', 'ðŸ§ª')
                    
                    sh '''
                        cd backend-service
                        pytest tests/ --verbose || echo "âš ï¸  No tests yet"
                    '''
                }
            }
        }

        stage('Build Docker Images') {
            parallel {
                stage('Build Backend') {
                    steps {
                        script {
                            logMessage('Building Backend Docker Image', 'ðŸ”¨')
                            
                            sh 'docker rmi connecthub-backend:latest tomernos/connecthub-backend:latest || true'
                            sh 'docker rmi connecthub-frontend:latest tomernos/connecthub-frontend:latest || true'

                            def backendImage = dockerBuild(
                                imageName: 'connecthub-backend',
                                tag: 'latest',
                                context: './backend-service',
                                dockerfile: './backend-service/Dockerfile'
                            )
                            
                            saveDockerImage(
                                imageName: backendImage.imageName,
                                tag: backendImage.tag,
                                outputFile: 'backend.tar.gz'
                            )
                        }
                    }
                }
                
                stage('Build Frontend') {
                    steps {
                        script {
                            logMessage('Building Frontend Docker Image', 'ðŸŒ')
                            
                            def frontendImage = dockerBuild(
                                imageName: 'connecthub-frontend',
                                tag: 'latest',
                                context: './frontend-service',
                                dockerfile: './frontend-service/Dockerfile'
                            )
                            
                            saveDockerImage(
                                imageName: frontendImage.imageName,
                                tag: frontendImage.tag,
                                outputFile: 'frontend.tar.gz'
                            )
                        }
                    }
                }
            }
        }

        stage('Tag Images') {
            steps {
                script {
                    logMessage('Tagging Images', 'ðŸ·ï¸')
                    
                    sh '''
                        docker tag connecthub-backend:latest tomernos/connecthub-backend:latest
                        docker tag connecthub-frontend:latest tomernos/connecthub-frontend:latest
                        docker images | grep connecthub
                    '''
                }
            }
        }

        stage('Authenticate to AWS & Set ECR Registry') {
            // Always run this stage if we need to push to ECR
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    expression { env.BRANCH_NAME =~ /^release\// }
                    expression { env.BRANCH_NAME =~ /^hotfix\// }
                    expression { 
                        def branch = env.BRANCH ?: env.BRANCH_NAME ?: ''
                        return branch.contains('develop') || 
                               branch.contains('main') || 
                               branch.contains('staging') ||
                               branch.contains('release') ||
                               branch.contains('hotfix')
                    }
                }
            }
            steps {
                script {
                    logMessage('Authenticating to AWS and setting ECR registry', 'ðŸ”')
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        // Install AWS CLI if not available
                        sh '''
                            set -e
                            if ! command -v aws &> /dev/null; then
                                echo "ðŸ“¦ Installing AWS CLI..."
                                apt-get update -qq
                                apt-get install -y -qq curl unzip
                                curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                unzip -q awscliv2.zip
                                ./aws/install
                                rm -rf awscliv2.zip aws
                                echo "âœ… AWS CLI installed"
                            else
                                echo "âœ… AWS CLI already installed"
                                aws --version
                            fi
                        '''
                        
                        // Verify AWS credentials are set and get account ID
                        echo "ðŸ” Getting AWS account ID..."
                        echo "AWS_REGION: ${env.AWS_REGION}"
                        echo "BRANCH: ${BRANCH}"
                        echo "BRANCH_NAME: ${env.BRANCH_NAME}"
                        
                        def accountId = sh(
                            script: """
                                set -e
                                # Credentials are already available from withCredentials
                                if [ -z "\${AWS_ACCESS_KEY_ID}" ] || [ -z "\${AWS_SECRET_ACCESS_KEY}" ]; then
                                    echo "âŒ AWS credentials not available in shell!"
                                    exit 1
                                fi
                                echo "âœ… AWS credentials available"
                                
                                # Set region
                                export AWS_DEFAULT_REGION=${env.AWS_REGION ?: 'eu-central-1'}
                                
                                # Get account ID
                                aws sts get-caller-identity --query Account --output text 2>&1
                            """,
                            returnStdout: true
                        ).trim()
                        
                        echo "Account ID response: '${accountId}'"
                        
                        if (!accountId || accountId.isEmpty() || accountId.contains("error") || accountId.contains("Unable") || accountId.contains("None") || accountId.contains("Unable to locate credentials")) {
                            error("Failed to get AWS account ID. Response: '${accountId}'. Check AWS credentials and region.")
                        }
                        
                        env.AWS_ACCOUNT_ID = accountId
                        
                        // Get region from environment
                        def region = env.AWS_REGION ?: 'eu-central-1'
                        env.ECR_REGISTRY = "${accountId}.dkr.ecr.${region}.amazonaws.com"
                        env.AWS_DEFAULT_REGION = region
                        
                        echo "âœ… AWS authenticated successfully"
                        echo "Account ID: ${accountId}"
                        echo "Region: ${region}"
                        echo "ECR Registry: ${env.ECR_REGISTRY}"
                        
                        // Verify ECR registry is set
                        if (!env.ECR_REGISTRY || env.ECR_REGISTRY.isEmpty()) {
                            error("ECR_REGISTRY is not set! Cannot proceed with ECR operations.")
                        }
                    }
                }
            }
        }

        stage('Push to ECR') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    expression { env.BRANCH_NAME =~ /^release\// }
                    expression { env.BRANCH_NAME =~ /^hotfix\// }
                    expression { 
                        def branch = env.BRANCH ?: env.BRANCH_NAME
                        return branch ==~ /.*develop.*/ || 
                               branch ==~ /.*main.*/ || 
                               branch ==~ /.*staging.*/
                    }
                }
            }
            steps {
                script {
                    logMessage("Pushing Images to ECR", 'ðŸ“¤')
                    
                    // Verify ECR_REGISTRY is set, if not try to set it
                    if (!env.ECR_REGISTRY || env.ECR_REGISTRY.isEmpty()) {
                        echo "âš ï¸  ECR_REGISTRY not set, attempting to set it now..."
                        withCredentials([usernamePassword(
                            credentialsId: AWS_CREDENTIALS_ID,
                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        )]) {
                            // Install AWS CLI if not available
                            sh '''
                                set -e
                                if ! command -v aws &> /dev/null; then
                                    echo "ðŸ“¦ Installing AWS CLI..."
                                    apt-get update -qq
                                    apt-get install -y -qq curl unzip
                                    curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                    unzip -q awscliv2.zip
                                    ./aws/install
                                    rm -rf awscliv2.zip aws
                                    echo "âœ… AWS CLI installed"
                                fi
                            '''
                            
                            def accountId = sh(
                                script: """
                                    export AWS_ACCESS_KEY_ID=\${AWS_ACCESS_KEY_ID}
                                    export AWS_SECRET_ACCESS_KEY=\${AWS_SECRET_ACCESS_KEY}
                                    export AWS_DEFAULT_REGION=${env.AWS_REGION ?: 'eu-central-1'}
                                    aws sts get-caller-identity --query Account --output text 2>&1
                                """,
                                returnStdout: true
                            ).trim()
                            
                            echo "Fallback Account ID response: '${accountId}'"
                            
                            if (accountId && !accountId.isEmpty() && !accountId.contains("error") && !accountId.contains("Unable") && !accountId.contains("None")) {
                                def region = env.AWS_REGION ?: 'eu-central-1'
                                env.ECR_REGISTRY = "${accountId}.dkr.ecr.${region}.amazonaws.com"
                                env.AWS_DEFAULT_REGION = region
                                echo "âœ… ECR_REGISTRY set: ${env.ECR_REGISTRY}"
                            } else {
                                error("ECR_REGISTRY is not set and cannot be auto-detected! Response: '${accountId}'. Check AWS credentials.")
                            }
                        }
                    }
                    
                    withCredentials([usernamePassword(
                        credentialsId: AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "ðŸ“¦ BUILD INFORMATION"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "Version:      ${env.VERSION}"
                            echo "Environment:  ${env.TARGET_ENVIRONMENT}"
                            echo "ECR Registry: ${env.ECR_REGISTRY}"
                            echo "Branch:       ${BRANCH}"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo ""
                            
                            # Login to ECR
                            echo "ðŸ” Logging into ECR..."
                            aws ecr get-login-password --region ${env.AWS_REGION} | docker login --username AWS --password-stdin ${env.ECR_REGISTRY}
                            
                            if [ \$? -ne 0 ]; then
                                echo "âŒ ECR login failed"
                                exit 1
                            fi
                            
                            # Verify ECR repository exists (created by Terraform)
                            echo "ðŸ“¦ Verifying ECR repository exists (created by Terraform)..."
                            if ! aws ecr describe-repositories --repository-names ${ECR_REPO} --region ${env.AWS_REGION} &>/dev/null; then
                                echo "âŒ ERROR: ECR repository '${ECR_REPO}' does not exist!"
                                echo "   Run Terraform to create ECR repository first."
                                exit 1
                            fi
                            
                            echo "âœ… ECR repository verified (created by Terraform)"
                            echo ""
                            echo "ðŸ·ï¸  Tagging images with ECR paths (same repository, different tags)..."
                            
                            # Tag backend: chatapp:backend-{version}
                            docker tag connecthub-backend:latest ${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}
                            docker tag connecthub-backend:latest ${env.ECR_REGISTRY}/${ECR_REPO}:backend-latest
                            echo "âœ… Tagged: ${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}"
                            
                            # Tag frontend: chatapp:frontend-{version}
                            docker tag connecthub-frontend:latest ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}
                            docker tag connecthub-frontend:latest ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-latest
                            echo "âœ… Tagged: ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}"
                            
                            echo ""
                            echo "ðŸ“¤ Pushing images to ECR..."
                            
                            # Push backend
                            docker push ${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}
                            docker push ${env.ECR_REGISTRY}/${ECR_REPO}:backend-latest
                            echo "âœ… Pushed: ${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}"
                            
                            # Push frontend
                            docker push ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}
                            docker push ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-latest
                            echo "âœ… Pushed: ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}"
                            
                            echo ""
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "âœ… IMAGES PUBLISHED TO ECR"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "Repository: ${env.ECR_REGISTRY}/${ECR_REPO}"
                            echo "Version: ${env.VERSION}"
                            echo "Backend:  ${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}"
                            echo "Frontend: ${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                        """
                    }
                }
            }
        }

        stage('Update Deployment Manifest') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    expression { env.BRANCH_NAME =~ /^release\// }
                    expression { env.BRANCH_NAME =~ /^hotfix\// }
                }
            }
            steps {
                script {
                    logMessage('Updating Deployment Manifest', 'ðŸ“')
                    
                    // Determine deployment file using Groovy logic (no shell script)
                    def deploymentFile = null
                    def normalizedBranch = BRANCH.replaceAll('origin/', '')
                    
                    if (normalizedBranch == 'develop') {
                        deploymentFile = 'deployments/dev/deployment.yaml'
                    } else if (normalizedBranch =~ /^release\//) {
                        deploymentFile = 'deployments/staging/deployment.yaml'
                    } else if (normalizedBranch == 'main' || normalizedBranch =~ /^hotfix\//) {
                        deploymentFile = 'deployments/prod/deployment.yaml'
                    }
                    
                    if (!deploymentFile) {
                        echo "âš ï¸  Branch ${BRANCH} does not update deployment files (feature branch)"
                        return
                    }
                    
                    echo "ðŸ“ Updating deployment file: ${deploymentFile}"
                    
                    // Get current timestamp
                    def timestamp = new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))
                    
                    // Create deployment manifest content
                    def manifestContent = """# Deployment Manifest - Auto-generated by CI
# DO NOT manually edit - CI will overwrite changes
# Last updated: ${timestamp}

version: "${env.VERSION}"
ecr_registry: "${env.ECR_REGISTRY}"
ecr_repo: "${ECR_REPO}"
backend_image: "${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}"
frontend_image: "${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}"
deployed_at: "${timestamp}"
deployed_by: "jenkins"
git_commit: "${env.GIT_COMMIT}"
git_branch: "${normalizedBranch}"
"""
                    
                    // Write deployment file
                    writeFile file: deploymentFile, text: manifestContent
                    
                    // Configure git and commit (with [skip ci] to prevent loop)
                    withCredentials([usernamePassword(
                        credentialsId: GIT_CREDENTIALS_ID,
                        usernameVariable: 'GIT_USERNAME',
                        passwordVariable: 'GIT_PASSWORD'
                    )]) {
                        sh """
                            # Configure git
                            git config user.name "Jenkins CI"
                            git config user.email "jenkins@ci.local"
                            
                            # Add deployment file
                            git add ${deploymentFile}
                            
                            # Check if there are changes to commit
                            if git diff --staged --quiet; then
                                echo "â„¹ï¸  No changes to deployment file (version unchanged)"
                            else
                                # Commit with [skip ci] to prevent infinite loop
                                # Jenkins should be configured to ignore commits with [skip ci] in message
                                git commit -m "CI: Update deployment manifest to ${env.VERSION} [skip ci]" || true
                                
                                # Push changes
                                git remote set-url origin https://\${GIT_USERNAME}:\${GIT_PASSWORD}@\$(echo ${env.GIT_URL} | sed -E 's|.*github.com[:/](.*)\\.git|github.com/\\1|' | sed 's|git@||')
                                git push origin ${normalizedBranch} || echo "âš ï¸  Failed to push deployment manifest (may need manual push)"
                                
                                echo "âœ… Deployment manifest updated and committed with [skip ci]"
                            fi
                        """
                    }
                }
            }
        }

        stage('Archive Artifacts') {
            steps {
                script {
                    logMessage('Archiving Artifacts', 'ðŸ’¾')
                    
                    sh """
                            cat > artifacts/manifest.json << EOF
                            {
                            "version": "${env.VERSION}",
                            "environment": "${env.TARGET_ENVIRONMENT}",
                            "is_release": "${env.IS_RELEASE}",
                            "git_commit": "${env.GIT_COMMIT}",
                            "git_short_commit": "${GIT_SHORT_COMMIT}",
                            "git_branch": "${env.GIT_BRANCH}",
                            "git_tag": "${env.TAG_NAME ?: 'none'}",
                            "build_url": "${env.BUILD_URL}",
                            "timestamp": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                            "images": {
                                "backend": "${env.ECR_REGISTRY}/${ECR_REPO}:backend-${env.VERSION}",
                                "frontend": "${env.ECR_REGISTRY}/${ECR_REPO}:frontend-${env.VERSION}"
                            }
                            }
                            EOF
                        """
                    
                    archiveArtifacts artifacts: 'artifacts/*', 
                                   fingerprint: true,
                                   allowEmptyArchive: false
                    
                    logMessage('Artifacts archived successfully', 'âœ…')
                }
            }
        }
    }

    post {
        always {
            script {
                logMessage('CI Pipeline Completed', 'ðŸ“Š')
            }
        }
        success {
            script {
                logMessage('CI Pipeline Completed Successfully!', 'âœ…')
            }
        }
        failure {
            script {
                logMessage('CI Pipeline Failed!', 'âŒ')
            }
        }
    }
}

